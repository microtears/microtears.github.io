<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://microtears.github.io</id>
    <title>德卡先生的信箱</title>
    <updated>2019-07-17T09:37:00.928Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://microtears.github.io"/>
    <link rel="self" href="https://microtears.github.io/atom.xml"/>
    <subtitle>日子和我，都有点难过。</subtitle>
    <logo>https://microtears.github.io/images/avatar.png</logo>
    <icon>https://microtears.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, 德卡先生的信箱</rights>
    <entry>
        <title type="html"><![CDATA[Hide Desktop Icon[AutoHotKey]]]></title>
        <id>https://microtears.github.io/post/hide-desktop-iconautohotkey</id>
        <link href="https://microtears.github.io/post/hide-desktop-iconautohotkey">
        </link>
        <updated>2019-02-12T10:43:37.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Update</strong></p>
<pre><code class="language-autohotkey">/* Library:
 *      Hide Desktop Icon
 * Description:
 *      Hide the desktop icon by double clicking the right mouse button
 * Warnning:
 *      None.
 * Version:
 *      v1.0.5
 * Author:
 *      泠音
 */</code></pre>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Update</strong></p>
<pre><code class="language-autohotkey">/* Library:
 *      Hide Desktop Icon
 * Description:
 *      Hide the desktop icon by double clicking the right mouse button
 * Warnning:
 *      None.
 * Version:
 *      v1.0.5
 * Author:
 *      泠音
 */

&lt;!-- more --&gt;

intInterval:=300
~RButton::
    If(A_PriorHotkey &lt;&gt; &quot;~RBUtton&quot; or A_TimeSincePriorHotkey &gt; intInterval){
        KeyWait, RButton
        return
    }
If(check()){
    HideOrShowDesktopIcons()
    Sleep, 40
    Send, {Esc}
    return
}

check(){
    MouseGetPos,X,Y,ID,CLASS
    return CLASS==&quot;SysListView321&quot; 
        or CLASS==&quot;SHELLDLL_DefView1&quot;
        or CLASS==&quot;&quot;
        or WinExist(&quot;ahk_class WorkerW&quot; . &quot; ahk_id &quot; . CLASS)
}

HideOrShowDesktopIcons()
{
	ControlGet, class, Hwnd,, SysListView321, ahk_class Progman
	If class =
		ControlGet, class, Hwnd,, SysListView321, ahk_class WorkerW
 
	If DllCall(&quot;IsWindowVisible&quot;, UInt,class)
		WinHide, ahk_id %class%
	Else
		WinShow, ahk_id %class%
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Quick Switch Virtual Desktop[AutoHotkey]]]></title>
        <id>https://microtears.github.io/post/quick-switch-virtual-desktopautohotkey</id>
        <link href="https://microtears.github.io/post/quick-switch-virtual-desktopautohotkey">
        </link>
        <updated>2019-02-12T02:06:10.000Z</updated>
        <summary type="html"><![CDATA[<pre><code class="language-autohotkey">/* Library:
 *      Quick Switch Virtual Desktop
 * Description:
 *      在屏幕四周，任务栏，桌面上使用鼠标滚轮来切换虚拟桌面。
 * Warnning:
 *      None.
 * Version:
 *      v1.0.3
 * Author:
 *      泠音
 */</code></pre>
]]></summary>
        <content type="html"><![CDATA[<pre><code class="language-autohotkey">/* Library:
 *      Quick Switch Virtual Desktop
 * Description:
 *      在屏幕四周，任务栏，桌面上使用鼠标滚轮来切换虚拟桌面。
 * Warnning:
 *      None.
 * Version:
 *      v1.0.3
 * Author:
 *      泠音
 */

&lt;!-- more --&gt;

#MaxHotkeysPerInterval 300
WheelUp::
    If (isHook()){
        Send, {LWinDown}{CtrlDown}{Left Down}{LWinUp}{CtrlUp}{Left Up}
    }else{
        MouseClick, WheelUp
    }
    return

WheelDown::
    If (isHook()){
        Send, {LWinDown}{CtrlDown}{Right Down}{LWinUp}{CtrlUp}{Right Up}
    }else{
        MouseClick, WheelDown
    }
    return

isHook(){
    CoordMode, Mouse,Screen
    MouseGetPos, X,Y,ID,CLASS
    ; t1 := A_ScreenWidth-X
    ; t2 := A_ScreenHeight-Y
    ; MsgBox X:%X% Y:%Y% dw:%t1% dh:%t2% W:%A_ScreenWidth% H:%A_ScreenHeight%
    return MouseIsOver(&quot;ahk_class WorkerW&quot;) 
        or MouseIsOver(&quot;ahk_class Shell_TrayWnd&quot;) 
        or X == 0 
        or Y == 0
        or A_ScreenWidth-X&lt;2
        or A_ScreenHeight-Y&lt;2
}

MouseIsOver(WinTitle) {
    MouseGetPos,,, Win
    return WinExist(WinTitle . &quot; ahk_id &quot; . Win)
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JavaFx中Controller获取Stage并自定义窗口移动与缩放逻辑]]></title>
        <id>https://microtears.github.io/post/javafx-zhong-controller-huo-qu-stage-bing-zi-ding-yi-chuang-kou-yi-dong-yu-suo-fang-luo-ji</id>
        <link href="https://microtears.github.io/post/javafx-zhong-controller-huo-qu-stage-bing-zi-ding-yi-chuang-kou-yi-dong-yu-suo-fang-luo-ji">
        </link>
        <updated>2019-02-05T04:21:10.000Z</updated>
        <summary type="html"><![CDATA[<p>由于去掉了平台自带了标题栏，窗口就无法移动和缩放了，需要我们自己来实现。</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于去掉了平台自带了标题栏，窗口就无法移动和缩放了，需要我们自己来实现。</p>
<!-- more -->
<h2 id="去除窗口标题栏">去除窗口标题栏</h2>
<pre><code class="language-java">public class Main extends Application {

    @Override
    public void start(Stage primaryStage) throws Exception {
        Parent root = FXMLLoader.load(getClass().getResource(&quot;main.fxml&quot;));
        primaryStage.setTitle(&quot;main&quot;);
        // 主要是这一句
        primaryStage.initStyle(StageStyle.TRANSPARENT);
        primaryStage.setScene(new Scene(root));
        primaryStage.show();
    }


    public static void main(String[] args) {
        launch(args);
    }
}
</code></pre>
<h2 id="在controller中获取stage">在Controller中获取Stage</h2>
<p>首先确定在Controller中获取到你的跟布局对象，如下：</p>
<pre><code class="language-java">public class Controller implements Initializable {
    public BorderPane root;
    private Stage stage;
}
</code></pre>
<pre><code class="language-xml">&lt;BorderPane fx:id=&quot;root&quot; maxHeight=&quot;-Infinity&quot; maxWidth=&quot;-Infinity&quot; minHeight=&quot;-Infinity&quot; minWidth=&quot;-Infinity&quot; prefHeight=&quot;400.0&quot; prefWidth=&quot;600.0&quot; stylesheets=&quot;@../css/main.css&quot; xmlns=&quot;http://javafx.com/javafx/8.0.172-ea&quot; xmlns:fx=&quot;http://javafx.com/fxml/1&quot; fx:controller=&quot;line.main.Controller&quot;&gt;
      &lt;!--其他布局元素--&gt;
&lt;/BorderPane&gt;
</code></pre>
<p>然后可以在<code>public void initialize(URL url, ResourceBundle resourceBundle)</code>方法内获取Stage</p>
<pre><code class="language-java">public class Controller implements Initializable {
    public BorderPane root;
    private Stage stage;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
       var stage = getStage();
    }

    private Stage getStage() {
        if (stage == null) {
            stage = (Stage) root.getScene().getWindow();
        }
        return stage;
    }

}
</code></pre>
<h2 id="自定义窗体移动与缩放逻辑">自定义窗体移动与缩放逻辑</h2>
<ol>
<li>记录鼠标坐标<pre><code class="language-java"> root.setOnMousePressed(event -&gt; {
            event.consume();
            xOffset = event.getSceneX();
            yOffset = event.getSceneY();
        });
</code></pre>
</li>
<li>自定义移动控制区域<pre><code class="language-java">dragArea.setOnMouseDragged(event -&gt; {
            event.consume();
            var stage = getStage();
            stage.setX(event.getScreenX() - xOffset);
            stage.setY(event.getScreenY() - yOffset);
        });
</code></pre>
</li>
<li>判断鼠标坐标位置，并处理光标变换<pre><code class="language-java">root.setOnMouseMoved(this::mouseMoveHandle);

 private void mouseMoveHandle(MouseEvent event) {
        event.consume();
        double x = event.getSceneX();
        double y = event.getSceneY();
        var stage = getStage();
        double width = stage.getWidth();
        double height = stage.getHeight();
        Cursor cursorType = Cursor.DEFAULT;
        bit = 0;
        if (y &gt;= height - RESIZE_WIDTH) {
            if (x &lt;= RESIZE_WIDTH) {
                bit |= 1 &lt;&lt; 3;
            } else if (x &gt;= width - RESIZE_WIDTH) {
                bit |= 1;
                bit |= 1 &lt;&lt; 2;
                cursorType = Cursor.SE_RESIZE;
            } else {
                bit |= 1;
                cursorType = Cursor.S_RESIZE;
            }
        } else if (x &gt;= width - RESIZE_WIDTH) {
            bit |= 1 &lt;&lt; 2;
            cursorType = Cursor.E_RESIZE;
        }
        root.setCursor(cursorType);
    }
</code></pre>
</li>
<li>处理窗口缩放<pre><code class="language-java">root.setOnMouseDragged(this::mouseDraggedHandle);

private void mouseDraggedHandle(MouseEvent event) {
    event.consume();
    var primaryStage = getStage();
    double x = event.getSceneX();
    double y = event.getSceneY();
    double nextX = primaryStage.getX();
    double nextY = primaryStage.getY();
    double nextWidth = primaryStage.getWidth();
    double nextHeight = primaryStage.getHeight();
    if ((bit &amp; 1 &lt;&lt; 2) != 0) {
        nextWidth = x;
    }
    if ((bit &amp; 1) != 0) {
        nextHeight = y;
    }
    if (nextWidth &lt;= MIN_WIDTH) {
        nextWidth = MIN_WIDTH;
    }
    if (nextHeight &lt;= MIN_HEIGHT) {
        nextHeight = MIN_HEIGHT;
    }
    primaryStage.setX(nextX);
    primaryStage.setY(nextY);
    primaryStage.setWidth(nextWidth);
    primaryStage.setHeight(nextHeight);
}
</code></pre>
</li>
</ol>
<h2 id="完整代码">完整代码</h2>
<pre><code class="language-java">package line.main;

import javafx.fxml.Initializable;
import javafx.scene.Cursor;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;

import java.net.URL;
import java.util.ResourceBundle;

public class Controller implements Initializable {
    public BorderPane root;
    public Pane dragArea;
    private Stage stage;
    private double xOffset = 0;
    private double yOffset = 0;
    private int bit = 0;//left,right,top,bottom
    private static final double RESIZE_WIDTH = 5.00;
    private static final double MIN_WIDTH = 600.00;
    private static final double MIN_HEIGHT = 400.00;

    @Override
    public void initialize(URL url, ResourceBundle resourceBundle) {
        dragArea.setOnMouseDragged(event -&gt; {
            event.consume();
            var stage = getStage();
            stage.setX(event.getScreenX() - xOffset);
            stage.setY(event.getScreenY() - yOffset);
        });
        root.setOnMousePressed(event -&gt; {
            event.consume();
            xOffset = event.getSceneX();
            yOffset = event.getSceneY();
        });
        root.setOnMouseMoved(this::mouseMoveHandle);
        root.setOnMouseDragged(this::mouseDraggedHandle);
    }

    private Stage getStage() {
        if (stage == null) {
            stage = (Stage) root.getScene().getWindow();
        }
        return stage;
    }

    private void mouseMoveHandle(MouseEvent event) {
        event.consume();
        double x = event.getSceneX();
        double y = event.getSceneY();
        var stage = getStage();
        double width = stage.getWidth();
        double height = stage.getHeight();
        Cursor cursorType = Cursor.DEFAULT;
        bit = 0;
        if (y &gt;= height - RESIZE_WIDTH) {
            if (x &lt;= RESIZE_WIDTH) {
                bit |= 1 &lt;&lt; 3;
            } else if (x &gt;= width - RESIZE_WIDTH) {
                bit |= 1;
                bit |= 1 &lt;&lt; 2;
                cursorType = Cursor.SE_RESIZE;
            } else {
                bit |= 1;
                cursorType = Cursor.S_RESIZE;
            }
        } else if (x &gt;= width - RESIZE_WIDTH) {
            bit |= 1 &lt;&lt; 2;
            cursorType = Cursor.E_RESIZE;
        }
        root.setCursor(cursorType);
    }

    private void mouseDraggedHandle(MouseEvent event) {
        event.consume();
        var primaryStage = getStage();
        double x = event.getSceneX();
        double y = event.getSceneY();
        double nextX = primaryStage.getX();
        double nextY = primaryStage.getY();
        double nextWidth = primaryStage.getWidth();
        double nextHeight = primaryStage.getHeight();
        if ((bit &amp; 1 &lt;&lt; 2) != 0) {
            nextWidth = x;
        }
        if ((bit &amp; 1) != 0) {
            nextHeight = y;
        }
        if (nextWidth &lt;= MIN_WIDTH) {
            nextWidth = MIN_WIDTH;
        }
        if (nextHeight &lt;= MIN_HEIGHT) {
            nextHeight = MIN_HEIGHT;
        }
        primaryStage.setX(nextX);
        primaryStage.setY(nextY);
        primaryStage.setWidth(nextWidth);
        primaryStage.setHeight(nextHeight);
    }
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Idea VM options]]></title>
        <id>https://microtears.github.io/post/idea-vm-options</id>
        <link href="https://microtears.github.io/post/idea-vm-options">
        </link>
        <updated>2019-02-05T03:59:07.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-shell"># Custom IntelliJ IDEA VM options

##################JVM模式############################

# IDEA的JVM以Server模式启动（新生代默认使用ParNew）
-server


##################内存分配###########################

# 堆初始值占用3G，意味着IDEA启动即分配3G内存
-Xms3g

# 堆最大值占用3G
-Xmx3g

# 强制JVM在启动时申请到足够的堆内存（否则IDEA启动时堆初始大小不足3g）
-XX:+AlwaysPreTouch

# 年轻代与老年代比例为1:3（默认值是1:4），降低年轻代的回收频率
-XX:NewRatio=3

# 栈帧大小为16m
-Xss16m

##################老年代回收器########################

# 使用CMS老年代回收器
-XX:+UseConcMarkSweepGC

# CMS的重新标记步骤：多线程一起执行
-XX:+CMSParallelRemarkEnabled

# CMS的并发标记步骤：启用4个线程并发标记（理论上越多越好，前提是CPU核心足够多）
-XX:ConcGCThreads=8


##################JIT编译器###########################

# 代码缓存，用于存放Just In Time编译后的本地代码，如果塞满，JVM将只解释执行，不再编译native代码。
-XX:ReservedCodeCacheSize=512m

# 分层编译，JIT编译优化越来越好，IDEA运行时间越久越快
-XX:+TieredCompilation

# 节省64位指针占用的空间，代价是JVM额外开销
#-XX:+UseCompressedOops

# 增大软引用在JVM中的存活时长（堆空闲空间越大越久）
-XX:SoftRefLRUPolicyMSPerMB=50

# 设为false Idea会提示无法利用Https更新
-Djsse.enableSNIExtension=true

-ea
-Dsun.io.useCanonCaches=false
-Djava.net.preferIPv4Stack=true
-Djdk.http.auth.tunneling.disabledSchemes=&quot;&quot;
-XX:+HeapDumpOnOutOfMemoryError
-XX:-OmitStackTraceInFastThrow
-XX:MaxJavaStackTraceDepth=10000
-Dide.no.platform.update=true
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Tensorflow分类器项目自定义数据读入(v1)]]></title>
        <id>https://microtears.github.io/post/tensorflow-fen-lei-qi-xiang-mu-zi-ding-yi-shu-ju-du-ru-v1</id>
        <link href="https://microtears.github.io/post/tensorflow-fen-lei-qi-xiang-mu-zi-ding-yi-shu-ju-du-ru-v1">
        </link>
        <updated>2019-02-04T03:22:13.000Z</updated>
        <summary type="html"><![CDATA[<p>在照着Tensorflow官网的demo敲了一遍分类器项目的代码后，运行倒是成功了，结果也不错。但是最终还是要训练自己的数据，所以尝试准备加载自定义的数据，然而demo中只是出现了<code>fashion_mnist.load_data()</code>并没有详细的读取过程，随后我又找了些资料，把读取的过程记录在这里。<br>
首先提一下需要用到的模块：</p>
]]></summary>
        <content type="html"><![CDATA[<p>在照着Tensorflow官网的demo敲了一遍分类器项目的代码后，运行倒是成功了，结果也不错。但是最终还是要训练自己的数据，所以尝试准备加载自定义的数据，然而demo中只是出现了<code>fashion_mnist.load_data()</code>并没有详细的读取过程，随后我又找了些资料，把读取的过程记录在这里。<br>
首先提一下需要用到的模块：</p>
<!-- more -->
<pre><code class="language-python">import os

import keras
import matplotlib.pyplot as plt
from PIL import Image
from keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split
</code></pre>
<p>图片分类器项目，首先确定你要处理的图片分辨率将是多少，这里的例子为30像素：</p>
<pre><code class="language-python">IMG_SIZE_X = 30
IMG_SIZE_Y = 30
</code></pre>
<p>其次确定你图片的方式目录：</p>
<pre><code class="language-python">image_path = r'D:\Projects\ImageClassifier\data\set'
path = &quot;.\data&quot;
# 你也可以使用相对路径的方式
# image_path =os.path.join(path, &quot;set&quot;)
</code></pre>
<p>目录下的结构如下：</p>
<p><img src="https://s2.ax1x.com/2019/02/04/kJpuDK.png" alt="folder"></p>
<p>相应的label.txt如下：</p>
<pre><code class="language-TEXT">动漫
风景
美女
物语
樱花
</code></pre>
<p>接下来是接在labels.txt，如下：</p>
<pre><code class="language-python">label_name = &quot;labels.txt&quot;
label_path = os.path.join(path, label_name)
class_names = np.loadtxt(label_path, type(&quot;&quot;))
</code></pre>
<p>这里简便起见，直接利用了numpy的loadtxt函数直接加载。</p>
<p>之后便是正式处理图片数据了，注释就写在里面了：</p>
<pre><code class="language-python">re_load = False
re_build = False
# re_load = True
re_build = True

data_name = &quot;data.npz&quot;
data_path = os.path.join(path, data_name)
model_name = &quot;model.h5&quot;
model_path = os.path.join(path, model_name)

count = 0

# 这里判断是否存在序列化之后的数据，re_load是一个开关，是否强制重新处理，测试用，可以去除。
if not os.path.exists(data_path) or re_load:
    labels = []
    images = []
    print('Handle images')
    # 由于label.txt是和图片防止目录的分类目录一一对应的，即每个子目录的目录名就是labels.txt里的一个label，所以这里可以通过读取class_names的每一项去拼接path后读取
    for index, name in enumerate(class_names):
        # 这里是拼接后的子目录path
        classpath = os.path.join(image_path, name)
        # 先判断一下是否是目录
        if not os.path.isdir(classpath):
            continue
        # limit是测试时候用的这里可以去除
        limit = 0
        for image_name in os.listdir(classpath):
            if limit &gt;= max_size:
                break
            # 这里是拼接后的待处理的图片path
            imagepath = os.path.join(classpath, image_name)
            count = count + 1
            limit = limit + 1
            # 利用Image打开图片
            img = Image.open(imagepath)
            # 缩放到你最初确定要处理的图片分辨率大小
            img = img.resize((IMG_SIZE_X, IMG_SIZE_Y))
            # 转为灰度图片，这里彩色通道会干扰结果，并且会加大计算量
            img = img.convert(&quot;L&quot;)
            # 转为numpy数组
            img = np.array(img)
            # 由（30，30）转为（1，30，30）（即`channels_first`），当然你也可以转换为（30，30，1）（即`channels_last`）但为了之后预览处理后的图片方便这里采用了（1，30，30）的格式存放
            img = np.reshape(img, (1, IMG_SIZE_X, IMG_SIZE_Y))
            # 这里利用循环生成labels数据，其中存放的实际是class_names中对应元素的索引
            labels.append([index])
            # 添加到images中，最后统一处理
            images.append(img)
            # 循环中一些状态的输出，可以去除
            print(&quot;{} class: {} {} limit: {} {}&quot;
                  .format(count, index + 1, class_names[index], limit, imagepath))
    # 最后一次性将images和labels都转换成numpy数组
    npy_data = np.array(images)
    npy_labels = np.array(labels)
    # 处理数据只需要一次，所以我们选择在这里利用numpy自带的方法将处理之后的数据序列化存储
    np.savez(data_path, x=npy_data, y=npy_labels)
    print(&quot;Save images by npz&quot;)
else:
    # 如果存在序列化号的数据，便直接读取，提高速度
    npy_data = np.load(data_path)[&quot;x&quot;]
    npy_labels = np.load(data_path)[&quot;y&quot;]
    print(&quot;Load images by npz&quot;)
image_data = npy_data
labels_data = npy_labels
</code></pre>
<p>到了这里原始数据的加工预处理便已经完成，只需要最后一步，就和demo中<code>fashion_mnist.load_data()</code>返回的结果一样了。代码如下：</p>
<pre><code class="language-python"># 最后一步就是将原始数据分成训练数据和测试数据
train_images, test_images, train_labels, test_labels = \
    train_test_split(image_data, labels_data, test_size=0.2, random_state=6)
</code></pre>
<p>这里将相关信息打印的方法也附上：</p>
<pre><code class="language-python">print(&quot;_________________________________________________________________&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Name&quot;, &quot;Shape&quot;))
print(&quot;=================================================================&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Image Data&quot;, image_data.shape))
print(&quot;%-28s %-s&quot; % (&quot;Labels Data&quot;, labels_data.shape))
print(&quot;=================================================================&quot;)

print('Split train and test data,p=%')
print(&quot;_________________________________________________________________&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Name&quot;, &quot;Shape&quot;))
print(&quot;=================================================================&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Train Images&quot;, train_images.shape))
print(&quot;%-28s %-s&quot; % (&quot;Test Images&quot;, test_images.shape))
print(&quot;%-28s %-s&quot; % (&quot;Train Labels&quot;, train_labels.shape))
print(&quot;%-28s %-s&quot; % (&quot;Test Labels&quot;, test_labels.shape))
print(&quot;=================================================================&quot;)

</code></pre>
<p>之后别忘了归一化哟：</p>
<pre><code class="language-python">print(&quot;Normalize images&quot;)
train_images = train_images / 255.0
test_images = test_images / 255.0
</code></pre>
<p>最后附上读取自定义数据的完整代码：</p>
<pre><code class="language-python">import os

import keras
import matplotlib.pyplot as plt
from PIL import Image
from keras.layers import *
from keras.models import *
from keras.optimizers import Adam
from keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split

os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
# 支持中文
plt.rcParams['font.sans-serif'] = ['SimHei']  # 用来正常显示中文标签
plt.rcParams['axes.unicode_minus'] = False  # 用来正常显示负号
re_load = False
re_build = False
# re_load = True
re_build = True
epochs = 50
batch_size = 5
count = 0
max_size = 2000000000
IMG_SIZE_X = 30
IMG_SIZE_Y = 30
np.random.seed(9277)
image_path = r'D:\Projects\ImageClassifier\data\set'
path = &quot;.\data&quot;
data_name = &quot;data.npz&quot;
data_path = os.path.join(path, data_name)
model_name = &quot;model.h5&quot;
model_path = os.path.join(path, model_name)
label_name = &quot;labels.txt&quot;
label_path = os.path.join(path, label_name)
class_names = np.loadtxt(label_path, type(&quot;&quot;))
print('Load class names')
if not os.path.exists(data_path) or re_load:
    labels = []
    images = []
    print('Handle images')
    for index, name in enumerate(class_names):
        classpath = os.path.join(image_path, name)
        if not os.path.isdir(classpath):
            continue
        limit = 0
        for image_name in os.listdir(classpath):
            if limit &gt;= max_size:
                break
            imagepath = os.path.join(classpath, image_name)
            count = count + 1
            limit = limit + 1
            img = Image.open(imagepath)
            img = img.resize((30, 30))
            img = img.convert(&quot;L&quot;)
            img = np.array(img)
            img = np.reshape(img, (1, 30, 30))
            # img = skimage.io.imread(imagepath, as_grey=True)
            # if img.shape[2] != 3:
            #     print(&quot;{} shape is {}&quot;.format(image_name, img.shape))
            #     continue
            # data = transform.resize(img, (IMG_SIZE_X, IMG_SIZE_Y))
            labels.append([index])
            images.append(img)
            print(&quot;{} class: {} {} limit: {} {}&quot;
                  .format(count, index + 1, class_names[index], limit, imagepath))
    npy_data = np.array(images)
    npy_labels = np.array(labels)
    np.savez(data_path, x=npy_data, y=npy_labels)
    print(&quot;Save images by npz&quot;)
else:
    npy_data = np.load(data_path)[&quot;x&quot;]
    npy_labels = np.load(data_path)[&quot;y&quot;]
    print(&quot;Load images by npz&quot;)
image_data = npy_data
labels_data = npy_labels
print(&quot;_________________________________________________________________&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Name&quot;, &quot;Shape&quot;))
print(&quot;=================================================================&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Image Data&quot;, image_data.shape))
print(&quot;%-28s %-s&quot; % (&quot;Labels Data&quot;, labels_data.shape))
print(&quot;=================================================================&quot;)
train_images, test_images, train_labels, test_labels = \
    train_test_split(image_data, labels_data, test_size=0.2, random_state=6)
print('Split train and test data,p=%')
print(&quot;_________________________________________________________________&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Name&quot;, &quot;Shape&quot;))
print(&quot;=================================================================&quot;)
print(&quot;%-28s %-s&quot; % (&quot;Train Images&quot;, train_images.shape))
print(&quot;%-28s %-s&quot; % (&quot;Test Images&quot;, test_images.shape))
print(&quot;%-28s %-s&quot; % (&quot;Train Labels&quot;, train_labels.shape))
print(&quot;%-28s %-s&quot; % (&quot;Test Labels&quot;, test_labels.shape))
print(&quot;=================================================================&quot;)

# 归一化
# 我们将这些值缩小到 0 到 1 之间，然后将其馈送到神经网络模型。为此，将图像组件的数据类型从整数转换为浮点数，然后除以 255。以下是预处理图像的函数：
# 务必要以相同的方式对训练集和测试集进行预处理：
print(&quot;Normalize images&quot;)
train_images = train_images / 255.0
test_images = test_images / 255.0
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Google Translate的API调用]]></title>
        <id>https://microtears.github.io/post/google-translate-de-api-diao-yong</id>
        <link href="https://microtears.github.io/post/google-translate-de-api-diao-yong">
        </link>
        <updated>2019-02-04T03:21:50.000Z</updated>
        <summary type="html"><![CDATA[<p>由于经常用到谷歌翻译，而每次切换到网页又觉得耗费时间，所以决定自己写一个小工具来用，于是就去查询了一番谷歌翻译的API，但是看到都说是API已经开始收费了，但还是有人通过网页爬出了网页翻译的API但是利用起来比较繁琐。之后又找到了一个简单的API，如下：</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于经常用到谷歌翻译，而每次切换到网页又觉得耗费时间，所以决定自己写一个小工具来用，于是就去查询了一番谷歌翻译的API，但是看到都说是API已经开始收费了，但还是有人通过网页爬出了网页翻译的API但是利用起来比较繁琐。之后又找到了一个简单的API，如下：</p>
<!-- more -->
<pre><code class="language-kotlin">fun translate(text: String, source: String = &quot;auto&quot;, target: String = &quot;zh-CN&quot;): Pair&lt;String, String&gt; {
    val textChecked = if (text.isBlank()) &quot;null&quot; else URLEncoder.encode(text, &quot;utf8&quot;)
    val userAgent = &quot;Mozilla/5.0&quot;
    val url = &quot;https://translate.googleapis.com/translate_a/single?client=gtx&amp;sl=$source&amp;tl=$target&amp;dt=t&amp;q=$textChecked&quot;
    val connection = URL(url).openConnection().apply { setRequestProperty(&quot;User-Agent&quot;, userAgent) }
    val raw = connection.getInputStream().use { it.readBytes() }.toString(Charset.forName(&quot;utf8&quot;))
    val p1 = raw.indexOf(&quot;\&quot;,\&quot;&quot;)
    val p2 = raw.indexOf(&quot;\&quot;,&quot;, p1 + 1)
    val result = raw.substring(4, p1)
    val query = raw.substring(p1 + 3, p2)
    return Pair(result, query)
}
</code></pre>
<p>测试函数如下：</p>
<pre><code class="language-kotlin">fun main() {
    println(translate(&quot;别让这么应景的天空放晴啊&quot;))
    println(translate(&quot;空気を読んだ空晴れないでよ&quot;))

    println(translate(&quot;别降下这么看场合的雨啊&quot;))
    println(translate(&quot;空気を読んだ雨降らないでよ&quot;))

    println(translate(&quot;He sits no sure that sits too high&quot;))
    println(translate(&quot;高处不胜寒&quot;, target = &quot;en-US&quot;))
}
</code></pre>
<p>调用结果如下：</p>
<pre><code class="language-kotlin">(别让这么应景的天空放晴啊, 别让这么应景的天空放晴啊)
(我看空中的天空请不要晴天, 空気を読んだ空晴れないでよ)

(别降下这么看场合的雨啊, 别降下这么看场合的雨啊)
(看风雨时不要下雨, 空気を読んだ雨降らないでよ)

(他不确定是不是太高了, He sits no sure that sits too high)
(High altitude, 高处不胜寒)
</code></pre>
<p>translate函数参数分别是：需要翻译的字符串，原始语言（默认为auto，即自动检测），目标语言（默认zh-CN，即简体中文）。<br>
translate函数返回结果为：翻译后的字符串，需要翻译的字符串（原始字符串）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Idea插件使用]]></title>
        <id>https://microtears.github.io/post/idea-cha-jian-shi-yong</id>
        <link href="https://microtears.github.io/post/idea-cha-jian-shi-yong">
        </link>
        <updated>2019-02-04T03:16:57.000Z</updated>
        <content type="html"><![CDATA[<h2 id="activate-power-mode">activate-power-mode</h2>
<p>activate-power-mode for IDEA.<br>
根据Atom的插件activate-power-mode的效果移植到IDEA上</p>
<p>设置窗口在这里：</p>
<p><img src="https://s2.ax1x.com/2019/02/04/kJCCY4.png" alt="setting"></p>
<p>我喜欢打开colorful关闭combo，你们呢？</p>
<p><a href="https://plugins.jetbrains.com/plugin/8330-activate-power-mode">Download</a></p>
<h2 id="atom-material-icons">Atom Material Icons</h2>
<p>Replace Jetbrains' icons with Atom File Icons and Material Design Icons! This is a both a port of the Atom File Icons (https://github.com/file-icons/atom) and the Material Theme Icons (https://github.com/ChrisRM/material-theme-jetbrains) for Jetbrains products.</p>
<p>它好像会随着Material Theme UI一起安装。</p>
<p><a href="https://plugins.jetbrains.com/plugin/10044-atom-material-icons">Download</a></p>
<h2 id="material-theme-ui">Material Theme UI</h2>
<p>This will add the Material Theme look to your IDE.</p>
<p>很棒的一个主题<br>
设置在这里：<br>
<img src="https://s2.ax1x.com/2019/02/04/kJC11A.png" alt="setting"></p>
<p><a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui">Download</a></p>
<h2 id="rainbow-brackets">Rainbow Brackets</h2>
<p>Rainbow Brackets / Rainbow Parentheses for IntelliJ based IDEs<br>
Supported languages:</p>
<p>Java, Scala, Clojure, Kotlin, Python, Haskell, Agda, Rust, JavaScript, TypeScript, Erlang, Go, Groovy, Ruby, Elixir, ObjectiveC, PHP, HTML, XML, SQL, Apex language, C#, Dart ...</p>
<p><strong>Java</strong></p>
<p><img src="https://raw.githubusercontent.com/izhangzhihao/intellij-rainbow-brackets/IC-2017.2/screenshots/with-java.png" alt="img"></p>
<p><strong>With Material Theme UI</strong></p>
<p><img src="https://raw.githubusercontent.com/izhangzhihao/intellij-rainbow-brackets/IC-2017.2/screenshots/with-material-theme-ui.png" alt="img"></p>
<p><strong>Scala</strong></p>
<p><img src="https://raw.githubusercontent.com/izhangzhihao/intellij-rainbow-brackets/IC-2017.2/screenshots/with-scala.png" alt="img"></p>
<p><strong>Kotlin</strong></p>
<p><img src="https://raw.githubusercontent.com/izhangzhihao/intellij-rainbow-brackets/IC-2017.2/screenshots/with-kotlin.png" alt="img"></p>
<p><strong>Clojure</strong></p>
<p><img src="https://raw.githubusercontent.com/izhangzhihao/intellij-rainbow-brackets/IC-2017.2/screenshots/with-Clojure.png" alt="img"></p>
<p><strong>Html</strong></p>
<p><img src="https://raw.githubusercontent.com/izhangzhihao/intellij-rainbow-brackets/IC-2017.2/screenshots/with-HTML.png" alt="img"></p>
<p><strong>Gif</strong></p>
<p><img src="https://user-images.githubusercontent.com/10737066/40234968-46593fe2-5adb-11e8-8ea8-0026fad86ca9.gif" alt="img"><br>
<img src="https://user-images.githubusercontent.com/10737066/40235004-642dfe54-5adb-11e8-9fd7-648b92fab8f5.gif" alt="img"></p>
<p><a href="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets">Download</a></p>
<h2 id="wakatime">WakaTime</h2>
<p>Metrics, insights, and time tracking automatically generated from your programming activity.</p>
<p>Installation</p>
<ol>
<li>
<p>Inside your IDE, select Preferences -&gt; Plugins -&gt; Browse Repositories....</p>
</li>
<li>
<p>Search for wakatime.</p>
</li>
<li>
<p>Click the green Install Plugin button and confirm the installation.</p>
</li>
<li>
<p>Re-launch your IDE.</p>
</li>
<li>
<p>Enter your api key, then click Save.</p>
</li>
<li>
<p>Use your IDE like you normally do and your time will be tracked for you automatically.</p>
</li>
<li>
<p>Visit https://wakatime.com to see your logged time.</p>
</li>
</ol>
<p>Source Code: https://github.com/wakatime/jetbrains-wakatime</p>
<p><img src="https://plugins.jetbrains.com/files/7425/screenshot_18534.png" alt="setting"></p>
<p>chrome也有哦，附一张我的统计图：</p>
<p><img src="https://s2.ax1x.com/2019/02/04/kJCv3d.png" alt="myimg"></p>
<p>设置在这里：</p>
<p><img src="https://s2.ax1x.com/2019/02/04/kJC5cR.png" alt="setting"></p>
<p><a href="https://plugins.jetbrains.com/plugin/7425-wakatime">Download</a></p>
<p>#Android Studio</p>
<h2 id="android-wifi-adb">Android WiFi ADB</h2>
<p>Provides an action which allow you quickly connect your Android device over WiFi to install, run and debug your applications without a USB connected by pressing one button.<br>
Connect your device using a USB cable and press the Android WiFi ADB button. Once the device be connected over WiFi you'll see an IntelliJ/Android Studio notification. Now you can disconnect your USB cable and enjoy deploying, running and debugging your applications over WiFi.<br>
The version 2.0 enables a window to check which of your devices are connected or not and connect/disconnect it manually if needed.</p>
<p><img src="https://plugins.jetbrains.com/files/7983/screenshot_15524.png" alt="img"></p>
<p>有了它就不用数据先连接调试了，需要在同一个局域网下哦。</p>
<p><a href="https://plugins.jetbrains.com/plugin/7983-android-wifi-adb">Download</a></p>
<h2 id="database-navigator">Database Navigator</h2>
<p>Database development, scripting and navigation tool<br>
This product adds extensive database development and maintenance capabilities to the IntelliJ IDEA development environment and related products. Along with a qualified and IDE-compliant SQL and PL/SQL editor, it provides advanced database connection management, script execution support, database objects browsing, data and code editor, support for database compiler operations, method execution and debugging, database objects factory, as well as various navigation capabilities between all its components.<br>
See features overview on the support page.</p>
<p>Supported Databases:<br>
Oracle<br>
MySQL<br>
SQLite<br>
PostgreSQL</p>
<p>This tool is free for personal and commercial usage.<br>
Donations are very welcome though.</p>
<p>调试数据库有奇效。</p>
<p><a href="https://plugins.jetbrains.com/plugin/1800-database-navigator">Download</a></p>
<h2 id="json-to-kotlin-class-jsontokotlinclass">JSON To Kotlin Class (JsonToKotlinClass)</h2>
<p>Plugin for Kotlin to convert Json String into Kotlin data class code quickly</p>
<p>Fast use it with short cut key ALT + K on Windows or Option + K on Mac</p>
<p>Features:</p>
<p>Generating Kotlin data class from any legal JSON string or any URLs that returns a JSON string as response<br>
Generating Kotlin data class from any legal JSON text when right click on directory and select New -&gt; Kotlin data class File from JSON</p>
<p>Supporting (almostly) all kinds of JSON libs' annotation(Gson, Jackson, Fastjson, MoShi and LoganSquare, kotlinx.serialization(default custom value))</p>
<p>Customizing your own annotations</p>
<p>Initializing properties with default values</p>
<p>Allowing properties to be nullable(?)</p>
<p>Determining property nullability automatically</p>
<p>Renaming property names to be camelCase style when selecting a target JSON lib annotation．</p>
<p>Generating Kotlin data class as individual classes</p>
<p>Generating Kotlin data class as inner classes</p>
<p>Formatting any legal JSON string</p>
<p>Generating Map Type when json key is primitive type</p>
<p>Only create annotation when needed</p>
<p>Custom define data class parent class</p>
<p>Sort property order by Alphabetical</p>
<p>Make keyword property valid</p>
<p>Support Loading JSON From Paster/Local File/Http URL</p>
<p>Support customize your own plugin by Extension Module</p>
<p><img src="https://plugins.jetbrains.com/files/9960/screenshot_18032.png" alt="usage"></p>
<p><img src="https://plugins.jetbrains.com/files/9960/screenshot_18029.png" alt="usage"></p>
<p><a href="https://github.com/wuseal/JsonToKotlinClass"><em>Full Usage Documentation</em></a></p>
<p><a href="https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-">Download</a></p>
<p><a href="#"><em><strong>未完待续</strong></em></a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在VSCode中编写Kotlin/Java]]></title>
        <id>https://microtears.github.io/post/zai-vscode-zhong-bian-xie-kotlinjava</id>
        <link href="https://microtears.github.io/post/zai-vscode-zhong-bian-xie-kotlinjava">
        </link>
        <updated>2018-11-27T16:11:24.000Z</updated>
        <summary type="html"><![CDATA[<p>不希望每次运行一下代码就要去启动Android Studio这个庞然大物，正好vscode可以做一个轻量级的IDE，所以配置了vscode用来编写Kotlin程序</p>
]]></summary>
        <content type="html"><![CDATA[<p>不希望每次运行一下代码就要去启动Android Studio这个庞然大物，正好vscode可以做一个轻量级的IDE，所以配置了vscode用来编写Kotlin程序</p>
<!-- more -->
<h2 id="前言">前言</h2>
<p>不希望每次运行一下代码就要去启动Android Studio这个庞然大物，正好vscode可以做一个轻量级的IDE，所以配置了vscode用来编写Kotlin程序</p>
<h2 id="环境配置">环境配置</h2>
<p>首先可以在Android Studio的安装目录下找到Kotlin Compiler：<br>
<img src="https://s1.ax1x.com/2018/05/12/CBWw9J.png" alt="1"><br>
<img src="https://s1.ax1x.com/2018/05/12/CBW039.png" alt="1"><br>
在环境变量中添加以下项：<br>
值为：Kotlin Compiler Path\bin<br>
例如：D:\Program Files\Android\Android Studio\plugins\Kotlin\kotlinc\bin<br>
<img src="https://s1.ax1x.com/2018/05/12/CBW4gA.png" alt="1"><br>
然后再控制台输入命令<code>kotlinc -version</code>检测环境是否配置妥当<br>
如果正常，则如下图所示<br>
<img src="https://s1.ax1x.com/2018/05/12/CBhUSJ.png" alt="1"><br>
如果出现这种情况<br>
<img src="https://s1.ax1x.com/2018/05/12/CBhtW4.png" alt="1"><br>
则是jdk版本配置不正确或者JAVA环境配置错误所致，重新配置即可（推荐使用jdk1.8）</p>
<h2 id="配置vscode">配置VSCODE</h2>
<p>在vscode扩展中安装Kotlin Language和Code Runner这两个扩展包<br>
<img src="https://s1.ax1x.com/2018/05/12/CB4bE6.png" alt="1"><br>
<img src="https://s1.ax1x.com/2018/05/12/CB4qUK.md.png" alt="1"><br>
安装后重启加载扩展，就可以编写Kotlin代码并编译运行了,右键<code>Run Code</code>或者<code>Ctrl</code>+<code>Alt</code>+<code>N</code>运行程序，,OK，像这样<br>
<img src="https://s1.ax1x.com/2018/05/12/CB7My4.png" alt="1"><br>
但是我们发现，输出面板中文出现了乱码，可行的解决办法是在用户设置中添加一句<code>&quot;code-runner.runInTerminal&quot;: true,</code>，表示让Kotlin程序通过Terminal运行，就不会出现中文乱码了<br>
效果如下：<br>
<img src="https://s1.ax1x.com/2018/05/12/CB7alD.png" alt="1"><br>
而且在程序目录下还会生成相应的jar包，如：<br>
<img src="https://s1.ax1x.com/2018/05/12/CB7USO.png" alt="1"></p>
<h2 id="总结">总结</h2>
<p>至此，vscode关于Kotlin的配置就已经完成了.</p>
<p><em>Enjoy Your Code！</em><br>
<em>2018/08/31</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ kotlin val的一次错误运用]]></title>
        <id>https://microtears.github.io/post/kotlin-val-de-yi-ci-cuo-wu-yun-yong</id>
        <link href="https://microtears.github.io/post/kotlin-val-de-yi-ci-cuo-wu-yun-yong">
        </link>
        <updated>2018-11-27T16:09:38.000Z</updated>
        <summary type="html"><![CDATA[<p>由于kotlin中被val或var修饰成员自带getter()/setter()（被val 修饰的成员没有setter()），所以在定义变量名称的时候不再像Java那样在成员变量之前加入小写m，类似于<code>mApplication</code>；所以一段时间不曾在代码里看到getXXX或setXXX出现，所以有一下代码出现：</p>
]]></summary>
        <content type="html"><![CDATA[<p>由于kotlin中被val或var修饰成员自带getter()/setter()（被val 修饰的成员没有setter()），所以在定义变量名称的时候不再像Java那样在成员变量之前加入小写m，类似于<code>mApplication</code>；所以一段时间不曾在代码里看到getXXX或setXXX出现，所以有一下代码出现：</p>
<!-- more -->
<pre><code class="language-kotlin">    private var page = 1
    private val userModel = UserModel.instance
    private val statementModel by lazyNone { StatementModel() }
    var isRefresh = false
        private set
    val nextPage = statementModel.getPage(userModel.scholar, ++page)
</code></pre>
<p>注意以上代码中的nextPage，它的本意是调用nextPage然后获取下一页的数据，但是我却忽略了被val 修饰的成员并不能绑定一个函数，val 成员可以绑定一个lambda对象，以此来让它表现出类似于函数的效果，且调用方式也类似，例如：</p>
<pre><code class="language-kotlin">     val nextInt={  ++page}
     val value=nextInt()
</code></pre>
<p>但是 nextInt 任然是一个对象，只不过是比较特殊点的lambda对象罢了。所以在开头提到的代码中，利用val 修饰的成员来绑定函数是一个错误的行为，但为什么编译器没有提示出错呢，问题正是出在了<code>statementModel.getPage(userModel.scholar, ++page)</code>函数返回了一个对象而不是<code>Unit</code>，所以val 成员只是引用了该函数第一次运行的结果，由于返回的对象也非lambda对象，自然也不能像函数那样调用，所以正确的写法应该是如下所示:</p>
<pre><code class="language-kotlin">    private var page = 1
    private val userModel = UserModel.instance
    private val statementModel by lazyNone { StatementModel() }
    var isRefresh = false
        private set
    fun nextPage() = statementModel.getPage(userModel.scholar, ++page)
</code></pre>
<p>出现这个问题是由于对被val修饰成员的理解出现偏差，故记录之。</p>
<p><em>写于2018/11/28</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[QQ sdk和Android sdk 28的兼容处理]]></title>
        <id>https://microtears.github.io/post/qq-sdk-he-android-sdk-28-de-jian-rong-chu-li</id>
        <link href="https://microtears.github.io/post/qq-sdk-he-android-sdk-28-de-jian-rong-chu-li">
        </link>
        <updated>2018-11-27T16:06:46.000Z</updated>
        <summary type="html"><![CDATA[<p>Android 最新的SDK早就出来了，版本号为28，包含了很多新东西，用起来是爽了，可其中的坑是一个接一个的，今天主要说下集成QQ_SDK的时候遇到的一些问题</p>
]]></summary>
        <content type="html"><![CDATA[<p>Android 最新的SDK早就出来了，版本号为28，包含了很多新东西，用起来是爽了，可其中的坑是一个接一个的，今天主要说下集成QQ_SDK的时候遇到的一些问题</p>
<!-- more -->
<p>首先是Android这次在SDK_28中移除了QQ_SDK还在使用的Apache_HTTP组件，so，如果你想用上最新的SDK而且还要集成QQ登陆等功能，那么你需要这样做：<br>
在你的app下的build.gradle中添加下面这句话。</p>
<pre><code class="language-Groovy">android {
    //QQ_SDK使用了AndroidX去掉的Apache_Http组件
    useLibrary 'org.apache.http.legacy'
}
</code></pre>
<p>其次还使用了这些被移除的组件：<br>
同样在下面的位置添加相应的依赖。</p>
<pre><code class="language-Groovy">dependencies {
    implementation 'org.jbundle.util.osgi.wrapped:org.jbundle.util.osgi.wrapped.org.apache.http.client:4.1.2'
    //noinspection DuplicatePlatformClasses
    implementation 'commons-logging:commons-logging:1.2'
}
</code></pre>
<p>但如果你的项目开启了混淆，你会发现即是这样做了之后还是会报错，你还需要在你的混淆规则里添加以下规则：</p>
<pre><code class="language-proguard-rules">-keep class org.apache.** {*;}
-dontwarn org.apache.**
-keep class org.apache.http.** { *; }
-keep class android.net.http.** { *; }
-dontwarn org.apache.http.**
-dontwarn android.net.http.**
</code></pre>
<p>OK 解下来就可以正常使用了</p>
<p>下次再讲SDK_28中的新控件在使用方面的坑。</p>
<p><em>写于2018/08/30</em></p>
]]></content>
    </entry>
</feed>