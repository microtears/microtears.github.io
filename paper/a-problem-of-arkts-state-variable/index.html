<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  
  <meta name="description"
    content="岁月总是历久弥新，需要细细品尝。" />

  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
    rel="stylesheet">
  <!-- Google Fonts -->

  <!-- Highlight.js theme (swapped dynamically for dark mode) -->
  <link id="hljs-theme" rel="stylesheet"
    href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/a11y-light.min.css" />
  <link rel="stylesheet" href="/main.css" />
  
  <title>为什么你写的鸿蒙 State变量刷新为什么时好时坏</title>
  <script src="/theme.js" defer></script>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TQQBL084VX" />
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-TQQBL084VX");
  </script>
</head>

<body>
  <div id="container-main">
    <main>
      <div class="wrap">
        <article>
          
<div id="content">
  <h1 id="wei-shen-me-ni-xie-de-hong-meng-state-bian-liang-shua-xin-wei-shen-me-shi-hao-shi-pi">为什么你写的鸿蒙 State 变量刷新为什么时好时坏</h1>
<h2 id="bei-jing">背景</h2>
<p>有一次开发碰到了这样一个问题：下面的 Bad case 写法在鸿蒙上不会触发组件重新 build，进而导致页面状态没有刷新。</p>
<h2 id="bad-case-xie-fa">Bad case 写法</h2>
<pre data-lang="ts" class="language-ts "><code class="language-ts" data-lang="ts">class BadState {
  tick: number = 0

  constructor() {
    this.startTimer()
  }

  private startTimer() {
    setInterval(() =&gt; {
      this.tick++
    }, 1000)
  }
}

@Component
struct Bad {
  @State state: BadState = new BadState()

  build() {
    Stack() {
      Text(`Tick: ${this.state.tick}`)
    }
  }
}
</code></pre>
<h2 id="good-case-xie-fa">Good case 写法</h2>
<pre data-lang="ts" class="language-ts "><code class="language-ts" data-lang="ts">@Component
struct Good {
  @State state: GoodState = new GoodState()

  aboutToAppear(): void {
    this.state.startTimer()
  }

  build() {
    Stack() {
      Text(`Tick: ${this.state.tick}`)
    }
  }
}
</code></pre>
<h2 id="yuan-yin-fen-xi">原因分析</h2>
<p>Good case 逻辑：this 对象是被代理过的对象，具有监听与通知的功能。</p>
<p><img src="https://s21.ax1x.com/2024/12/13/pAboZE6.png" alt="pAboZE6.png" /></p>
<p>Bad case 逻辑：this 对象为原始对象，无监听与通知的功能。</p>
<p><img src="https://s21.ax1x.com/2024/12/13/pAboeUK.png" alt="pAboeUK.png" /></p>
<p>而上述两种逻辑差异点主要是 startTimer 的 caller 不同：Good case 中 startTimer 的 caller 是 this.state 对象，这是一个被代理过的对象；Bad 中 startTimer 的 caller 是 this 对象，即 BadState 实例本身，这是一个没有被代理过的对象。
所以根据上述分析得出结论： Bad case 中箭头函数对应的 this 指针所指的对象为 startTimer 方法的 caller， 它是一个没有被代理过的对象，对该对象的任何属性的修改都不会被 View 层感知。</p>

</div>

        </article>
        <nav>
          <a id="avatar-container" href="/">
  <img id="avatar" title="lingyin" src="https://avatars.githubusercontent.com/u/13548822" />
</a>
<p>岁月总是历久弥新，需要细细品尝。</p>
<p>
  欢迎来到<a href="https://github.com/microtears"> lingyin </a>的开发者日志,
  这里是我的一些奇思妙想。
</p>
<p>
  它使用
  <a href="https://www.getzola.org/"> Zola </a>生成。
</p>
<div id="nav-break"></div>
<p id="copyright">© 2019-2025 <a href="/">lingyin</a>.
</p>
        </nav>
      </div>
      <footer>
        
<p id="build-time">Build time: 2025-11-03
</p>
<p id="run-time">Run   time: 0000d 00h 00m 00s</p>



<script>
  function updateTime() {
    const date1 = "2019/07/17 00:00:00";
    const date2 = new Date();
    const date3 = date2.getTime() - new Date(date1).getTime();
    const days = Math.floor(date3 / (24 * 3600 * 1000));
    const leave1 = date3 % (24 * 3600 * 1000);
    const hours = Math.floor(leave1 / (3600 * 1000));
    const leave2 = leave1 % (3600 * 1000);
    const minutes = Math.floor(leave2 / (60 * 1000));
    const leave3 = leave2 % (60 * 1000);
    const seconds = Math.round(leave3 / 1000);
    const element = document.getElementById("run-time");
    element.innerHTML =
      "Run   time: " + days + "d " + hours.toString().padStart(2, '0') + "h " + minutes.toString().padStart(2, '0') + "m " + seconds.toString().padStart(2, '0') + "s";
  }

  setInterval(updateTime, 1000);
</script>
      </footer>
      
    </main>
  </div>
  
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/dart.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/go.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/java.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/kotlin.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/rust.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/shell.min.js"></script>
<script
  src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/typescript.min.js"></script>

<script>hljs.highlightAll();</script>



</body>

</html>