<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="岁月总是历久弥新，需要细细品尝。">

  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/a11y-light.min.css" />

  <link rel="stylesheet" href="/article/style/main.css" />

  <title>简单记录</title>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TQQBL084VX" />
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-TQQBL084VX");
  </script>
</head>
<body>
  <main>
    <div class="wrap">
      <article>
        
        <div id="content"></div>
        
        <script type="module">
          import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
        
          const md = "## 基本计数方法\n\n1. 容斥原理\n- $|A∪B∪C|=|A|+|B|+|C|+|B|-|A∩B|-|B∩C|-|C∩A|+|A∩B∩C|$\n\n2. 排列问题\n- 全排列\n$P（n,k)=n(n-1)(n-2)...(n-k+1)=n!/(n-k)!$\n- 组合数\n$C（n,k)=P(n,k)/P(k,k)=n!/((n-k)!k!)$\n    - 性质 1：\n$C(n,0)=C(n,n)=1$\n    - 性质 2：\n$C(n,k)=C(n,n-k)$\n    - 性质 3：\n$C(n,k)+C(n,k+1)=C(n+1,k+1)$\n    - 性质 4：\n$C(n,k+1)=C(n,k)*(n-k)/(k+1)$\n\n3. 递推关系\n\n- 斐波那契（Fibonacci）数列\n$f(n)=f(n-1)+f(n-2),f(1)=f(2)=1$\n- 卡特兰（Catalan）数列\n$f(n)=f(2)f(n-1)+f(3)f(n-2)+...+f(n-1)f(2),f(2)=f(3)=1,[f(k)f(n-k-1)]$\n## 数论\n\n一. 基本概念\n  1. 素数\n```C++\n//筛素数\nconst int maxn=10000000+10;\nconst int maxp=700000;\nint vis[maxn];\nint prime[maxp];\nvoid sieve(int n){\n	int m=(int)sqrt(n+0.5);\n	memset(vis,0,sizeof(vis));\n	for(int i=2;i<=m;i++) if(!vis[i])//0为素数\n		for(int j=i*i;j<=n;j+=i) vis[j]=1;\n}\n//生成素数表\nint gen_prime(int n){\n	sieve(n);\n	int c=0;\n	for(int i=2;i<=n;i++) if(!vis[i])\n		prime[c++]=i;\n	return c;\n}\n```\n2. 欧几里得算法\n```C++\ntypedef long long ll;\nll gcd(ll a,ll b){\n	return b==0?a:gcd(b,a%b);\n}\nvoid gcd(ll a,ll b,ll &d,ll &x,ll &y){\n	if(!b){d=a;x=1;y=0;}\n	else{gcd(b,a%b,d,y,x);y-=x*(a/b);}\n}\n```\n3. 模算数\n```C++\n//返回ab mod n 要求0<=a,b<n\nll mul_mod(ll a,ll b,ll n){\n	return a*b%n;\n}\n//返回a^p mod n,要求0<=a<n\nll pow_mod(ll a,ll p,ll n){\n	if(p==0) return 1;\n	ll r=pow_mod(a,p/2,n);\n	r=r*r%n;\n	if(p%2==1) r=r*a%n;\n	return r;\n}\n```\n4. 欧拉phi函数（phi（x）表示等于不超过x且和x互素的整数个数）\n	$φ(x)=n(1-1/p1)(1-1/p2)...(1-1/pk)$\n```C++\n//计算欧拉phi函数\nint euler_phi(int n){\n	int m=(int)sqrt(n+0.5);\n	int ans=n;\n	for(int i=2;i<=m;i++) if(n%i==0){\n		ans=ans/i*(i-1);\n		while(n%i==0) n/=i;\n	}\n	if(n>1) ans=ans/n*(n-1);\n}\n//用类似筛法的方法计算phi（1），phi（2），...，phi（n）\nint phi[maxn];\nvoid phi_table(int n){\n	for(int i=2;i<=n;i++) phi[i]=0;\n	phi[1]=1;\n	for(int i=2;i<=n;i++) if(!phi[i])\n		for(int j=i;j<=n;j+=i){\n			if(!phi[j]) phi[j]=j;\n			phi[j]=phi[j]/i*(i-1);\n		}\n}\n```\n5. 剩余系\n\n```C++\n//计算模n下a的逆 如果不存在逆，返回-1\nll inv(ll a,ll n){\n	ll d,x,y;\n	gcd(a,n,d,x,y);\n	return d==1?(x+n)%n:-1;\n}\n```\n## 其他\n- 模拟，贪心，二分，三分，动态规划，容斥原理\n- 四舍五入：$floor(pos + 0.5) OR (x+s-1)/s$\n- 错排公式：$D(n)=(n-1)(D(n-2)+D(n-1))$\n- 判断凹凸多边形：$p1(x1,y1),p2(x2,y2),p3(x3,y3)$\n$s(p1,p2,p3)=(x1-x3)*(y2-y3)-(x2-x3)*(y1-y3)$\n如果s>0则说明这3个点时是按照逆时针的顺序，如果是s<0则说明连接这3个点是按照顺时针的顺序。\n- 三角形面积:\n$|a×b|=|a||b|sin(θ)$\n$S=1/2|a×b|$\n$p1(x1,y1),p2(x2,y2),p3(x3,y3)$\n$v1(x2-x1,y2-y1),v2(x3-x2,y3-y2)$\n$v1(x1,y1),v2(x2,y2)$\n$a×b=(x1y2-x2y1)$\n## 模板\n\n1. 尺取法，滑动窗口\n```C++\nset<int> s;\nwhile (r<n){\n	while (r<n&&!s.count(a[r]))\n		s.insert(a[r++]);\n	m=max(m,r-l);\n	s.erase(a[l++]);\n}\n```\n2. 归并排序，统计逆序对\n```C++\nexp1：\nint A[maxn], T[maxn];\n__int64 cnt=0,n;\nvoid merge(int *arr,int *tmp,int l, int mid,int r){\n	int i=l, j=mid+1, k=l;\n	while (i<=mid&&j<=r){\n		if (arr[i]<=arr[j]) tmp[k++]=arr[i++];\n		else{tmp[k++]=arr[j++];cnt+=mid-i+1;}\n	}\n	while (i!=mid+1) tmp[k++]=arr[i++];\n	while (j!=r+1) tmp[k++]=arr[j++];\n	for (i=l;i<=r; i++) arr[i]=tmp[i];\n}\nvoid mergesort(int *arr, int *tmp, int l, int r){\n	if (l<r){\n		int mid=(l+r)/2;\n		mergesort(arr,tmp,l,mid);\n		mergesort(arr,tmp,mid+1,r);\n		merge(arr,tmp,l,mid,r);\n	}\n}\nexp2:\nvoid mergesort(int *A,int *T,int x,int y){\n	if(y-x>1){\n		int m=(x+y)/2;\n		mergesort(A,T,x,m);\n		mergesort(A,T,m,y);\n		int i=x,j=m,k=i;\n		while(i<m||j<y){\n			if(j>=y||(i<m&&a[i]<=a[j])) T[k++]=A[i++];\n			else {T[k++]=A[j++];cnt=m-p;}\n		}\n		for(k=0;k<y;k++) A[k]=T[k];\n	}\n}\n```\n3. 快速幂\n```C++\nint pow(int a,int b){\n	int r=1,base=b;\n	while(b){\n		if(b&1) r*=base;\n		base*=base;\n		b>>=1;\n	}\n	return r;\n}\n```\n4. GCD/LCM\n```C++\nint gcd(int a,int b){\n	if(a==0) return b;\n	else if(b==0) return a;\n	else if(a%2==0&&b%2==0) return 2*gcd(a>>1,b>>1);\n	else if(a%2==0) return gcd(a>>1,b);\n	else if(b&2==0) return gcd(a,b>>1);\n	else return gcd(abs(a-b),min(a,b));\n}\nint gcd(int a,int b){\n	return b==0？a：gcd(b,a%b)；\n}\nint lcm(int a,int b){\n	return a/gcd(a,b)*b;\n}\n```\n5. 分解质因数，约数个数定理\n```C++\nint apx(ll n){\n	ll m=(int)sqrt(n+0.5);\n	int sum=1;\n	for (ll i=2;i<=m;++i){\n		int p=0;\n		while (n%i==0) {p++;n/=i;}\n		if (p>0) sum*=(p+1);\n	}\n	if (t>1) sum*=2;\n	return sum;\n}\n```\n6. 快速排序\n```C++\nvoid quicksort(int *A,int x,int y){\n	if(x<y){\n		int i=x,j=y,k=A[x];\n		while(i<j){\n			while(i<j&&A[j]>=k) j--;\n			if(i<j) A[i++]=A[j];\n			while(i<j&&A[i]<=k) i++;\n			if(i<j) A[j--]=A[i];\n			a[i]=k;\n		}\n		quicksort(A,x,i-1);\n		quicksort(A,j+1,y);\n	}\n}\n```\n7. 找最长递增子序列（LIS）\n```C++\nPII v[5050];\nint a[5050];\n//input\nsort(v, v + d);\nFORi(i, 0, d+1) a[i] = inf;\n//找最长递增子序列（LIS）\nFORi(i, 0, d) *lower_bound(a, a + d + 1, v[i].second) = v[i].second;//upper_lound为最长不下降子序列\ncout << distance(a,lower_bound(a, a + d + 1, inf)) << endl;\n```\n8. 斯特灵公式 (Stirling's approximation)\n\n	$n! \approx \sqrt{2\pi n}\, \left(\frac{n}{e}\right)^{n}.$\n```C++\nlen=(n*log(n)-n+0.5*log(2*n*PI))/(log(10))+1;\n```\n9. 回文子串 Manacher 算法\n```C++\nchar s[110200], sn[220400];\nint p[220400];\nint Manacher()\n{\n	int len=strlen(s);\n	sn[0] = '$';\n	sn[1] = '#';\n	int j = 2;\n	for (int i = 0; i < len; i++)\n	{\n		sn[j++] = s[i];\n		sn[j++] = '#';\n	}\n	sn[j] = '\0';\n	int mxlen = -1, mid, mx = 0;\n	for (int i = 1; i < j; i++)\n	{\n		p[i] = i < mx ? min(p[2 * mid - i], mx - i) : 1;\n		while (sn[i - p[i]] == sn[i + p[i]]) p[i]++;\n		if (mx < i + p[i]) { mid = i; mx = i + p[i]; }\n		mxlen = max(mxlen, p[i] - 1);\n	}\n	return mxlen;\n}\n```";
          document.getElementById('content').innerHTML = marked.parse(md);
        
          
        
        </script>
        
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/dart.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/go.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/java.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/kotlin.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/rust.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/shell.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/typescript.min.js"></script>
        
        <script>hljs.highlightAll();</script>
      </article>
      <nav>
        
        <a id="avatar-container" href="/">
          <img
            id="avatar"
            title="lingyin"
            src="https://avatars.githubusercontent.com/u/13548822"
          />
        </a>
        <p>岁月总是历久弥新，需要细细品尝。</p>
        <p>
          欢迎来到<a href="https://github.com/microtears"> lingyin </a>的开发者日志,
          这里是我的一些奇思妙想。
        </p>
        <p>
          它使用
          <a href="https://dart.dev/"> Dart </a>编写的一个专用于这个网站的静态网站生成器生成。
        </p>
        <div id="nav-break"></div>
        <p id="copyright">© 2019-2025 <a href="/">lingyin</a>.</p>
      </nav>
    </div>
    <footer>
      <p id="run-time"></span>
      <p id="build-time">Build time: 2025/10/10 10:4:35</span>
      <script>
        function updateTime() {
          const date1 = "2019/07/17 00:00:00";
          const date2 = new Date();
          const date3 = date2.getTime() - new Date(date1).getTime();
          const days = Math.floor(date3 / (24 * 3600 * 1000));
          const leave1 = date3 % (24 * 3600 * 1000);
          const hours = Math.floor(leave1 / (3600 * 1000));
          const leave2 = leave1 % (3600 * 1000);
          const minutes = Math.floor(leave2 / (60 * 1000));
          const leave3 = leave2 % (60 * 1000);
          const seconds = Math.round(leave3 / 1000);
          const element = document.getElementById("run-time");
          element.innerHTML =
            "Run   time: " + days + "d " + hours + "h " + minutes + "m " + seconds + "s";
        }

        setInterval(updateTime, 1000);
      </script>
    </footer>
  </main>
</body>
</html>