<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="岁月总是历久弥新，需要细细品尝。">

  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/a11y-light.min.css" />

  <link rel="stylesheet" href="/article/style/main.css" />

  <title>Flutter在平台方法调用中异步返回结果</title>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-TQQBL084VX" />
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());

    gtag("config", "G-TQQBL084VX");
  </script>
</head>
<body>
  <main>
    <div class="wrap">
      <article>
        
        <div id="content"></div>
        
        <script type="module">
          import { marked } from "https://cdn.jsdelivr.net/npm/marked/lib/marked.esm.js";
        
          const md = "\n# Flutter 在平台方法调用中异步返回结果\n\nasynchronous_method_channel 是一个在 Flutter 和 Native 之间异步调用方法时，支持异步返回结果的插件。\n\n在利用 Flutter 编写跨平台应用时，一些功能需要调用 Native 方法才能实现，可以利用 Flutter 为我们提供的 MethodChannel 实现。对与 Flutter 来说，所有的 Native 方法调用都是异步返回的，但是对于 Native 来说，对于来自 Flutter 的方法调用，我们要返回的结果却不能异步返回，如果我们尝试在执行异步操作之后调用`result.success(something)`，执行时会得到`java.lang.IllegalStateException: Reply already submitted`的错误信息。所以 AsynchronousMethodChannel 是对 MethodChannel 的一次封装，为其添加了异步返回方法调用结果的功能。因为对于 Flutter，和 Native 的通信即方法调用必须在平台主线程，但我们又知道应该尽量避免在主线程进行耗时操作，所以需要有一个措施来支持平台方法调用时异步返回结果，即编写本库的目的。\n\n## 关于 asynchronous_method_channel\n\n[Package](https://pub.dev/packages/asynchronous_method_channel): https://pub.dev/packages/asynchronous_method_channel\n\n[Example](https://github.com/microtears/asynchronous-method-channel/tree/master/example): https://github.com/microtears/asynchronous-method-channel/tree/master/example\n\n[Repository](https://github.com/microtears/asynchronous-method-channel): https://github.com/microtears/asynchronous-method-channel\n\n[Documentation](https://pub.dev/documentation/asynchronous_method_channel/latest/): https://pub.dev/documentation/asynchronous_method_channel/latest/\n\n[View/report issues](https://github.com/microtears/asynchronous-method-channel/issues): https://github.com/microtears/asynchronous-method-channel/issues\n\n## Flutter 配置\n\n- version: v1.9.1+hotfix.6\n- channel: master\n\n## 在 Android 上通过 AsynchronousMethodChannel 和 kotlin 编写插件\n\n下面是一个利用 kotlin 协程执行异步任务并返回结果的示例。\n\n在正式开始之前，需要我们了解的一件事是：Flutter 应用程序中 Android 模块的 gradle 不会自动导入我们需要的 Java 包，您必须手动添加以下代码。\n\n```kotlin\nimport io.flutter.plugins.asynchronous_method_channel.AsynchronousMethodChannel\n```\n\n```kotlin\nclass MainActivity: FlutterActivity() , AsynchronousMethodChannel.MethodCallHandler {\n    companion object{\n        const val CHANNEL=\"AsynchronousMethodChannelExample\"\n    }\n    private var parentJob = Job()\n    private val coroutineContext: CoroutineContext\n        get() = parentJob + Dispatchers.Main\n    private val scope = CoroutineScope(coroutineContext)\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        GeneratedPluginRegistrant.registerWith(this)\n        AsynchronousMethodChannel(flutterView, CHANNEL).setMethodCallHandler(this)\n    }\n\n\n    override fun onMethodCall(call: MethodCall, result: AsynchronousMethodChannel.Result) {\n        when (call.method) {\n            \"getBatteryLevel\" -> {\n                result.success(null)\n                scope.launch(Dispatchers.IO){\n                    // Do something\n                    // Perform asynchronous time-consuming tasks\n\n                    // Just return results after 2 seconds\n                    delay(2000)\n\n                    // The method in AsynchronousMethodChannel.Result must be called on the main thread of the platform\n                    scope.launch(Dispatchers.Main){\n                        result.successAsynchronous(getBatteryLevel().toString())\n                    }\n                }\n            }\n            else -> result.notImplemented()\n        }\n    }\n\n    private fun getBatteryLevel(): Int {\n        val batteryLevel: Int\n        batteryLevel = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager\n            batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)\n        } else {\n            val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))\n            intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)\n        }\n        return batteryLevel\n    }\n\n    override fun onDestroy() {\n        // cancel all asynchronous jobs\n        scope.cancel()\n        super.onDestroy()\n    }\n}\n```\n\n## 在 Flutter 上通过 AsynchronousMethodChannel 和 dart 编写插件\n\n下面是一个在 Flutter 应用程序中使用 AsynchronousMethodChannel 的示例。\n\n```dart\nclass _MyAppState extends State<MyApp> {\n  static final platform =\n      AsynchronousMethodChannel('AsynchronousMethodChannelExample');\n  String _batteryLevel = 'Unknown';\n  String _timeInfo = \"\";\n  static const style = TextStyle(\n    fontSize: 16,\n    fontFamily: \"monospace\",\n  );\n\n  @override\n  void initState() {\n    super.initState();\n    initPlatformState();\n  }\n\n  // Platform messages are asynchronous, so we initialize in an async method.\n  Future<void> initPlatformState() async {\n    String batteryLevel;\n    // Platform messages may fail, so we use a try/catch PlatformException.\n    try {\n      final sb = StringBuffer();\n      final startAt = DateTime.now();\n      sb.writeln(\"[start] [$startAt]\");\n      batteryLevel =\n          await platform.invokeAsynchronousMethod(\"getBatteryLevel\");\n      final endAt = DateTime.now();\n      sb.writeln(\"[end  ] [$endAt]\");\n      sb.writeln(\"[tag  ] [hours:minutes:seconds:us]\");\n      sb.writeln(\"[total] [${endAt.difference(startAt)}]\");\n      _timeInfo = sb.toString();\n    } on PlatformException {\n      batteryLevel = 'Failed to get platform version.';\n    }\n\n    // If the widget was removed from the tree while the asynchronous platform\n    // message was in flight, we want to discard the reply rather than calling\n    // setState to update our non-existent appearance.\n    if (!mounted) return;\n\n    setState(() {\n      _batteryLevel = batteryLevel;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: Scaffold(\n        appBar: AppBar(\n          title: const Text('AsynchronousMethodChannel example app'),\n        ),\n        body: Padding(\n          padding: const EdgeInsets.all(20.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: <Widget>[\n              Text('Battery level: $_batteryLevel\n', style: style),\n              Text(_timeInfo, style: style),\n              Center(\n                child: FlatButton(\n                  onPressed: initPlatformState,\n                  child: Text(\"Get battery level\"),\n                ),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## 截图\n\n![example](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/31/16e1d8c357a37f57~tplv-t2oaga2asx-image.image)\n\n## 在测试时使用 AsynchronousMethodChannel\n\n```dart\nvoid main() {\n  TestWidgetsFlutterBinding.ensureInitialized();\n\n  final AsynchronousMethodChannel channel =\n      AsynchronousMethodChannel('asynchronous_method_channel');\n\n  setUp(() {\n    channel.setMockAsynchronousMethodCallHandler(\n        (MethodCall methodCall, MockResult result) async {\n      switch (methodCall.method) {\n        case \"asynchronousMethod\":\n          // Delay 30 milliseconds to return results\n          Future.delayed(Duration(milliseconds: 30),\n              () => result.success(methodCall.arguments));\n          break;\n        case \"syncMethod\":\n          return \"ok\";\n          break;\n        case \"getBatteryLevel\":\n          result.success(\"100\");\n          break;\n      }\n      return null;\n    });\n  });\n\n  tearDown(() {\n    channel.setMockAsynchronousMethodCallHandler(null);\n  });\n\n  test('testMethod', () async {\n    expect(\n      await channel.invokeAsynchronousMethod(\n        \"asynchronousMethod\",\n        {\"arg\": \"arg1\"},\n      ),\n      {\"arg\": \"arg1\"},\n    );\n    expect(\n      await channel.invokeMethod(\"syncMethod\"),\n      \"ok\",\n    );\n    expect(\n      await channel.invokeAsynchronousMethod(\"getBatteryLevel\"),\n      \"100\",\n    );\n  });\n}\n```\n\n## 在 IOS 上使用 AsynchronousMethodChannel\n\n预计在下一个版本发布。\n\n## 关于更多\n\n请参阅[示例](https://github.com/microtears/asynchronous-method-channel/tree/master/example)。\n";
          document.getElementById('content').innerHTML = marked.parse(md);
        
          
        
        </script>
        
        
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/dart.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/go.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/java.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/kotlin.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/rust.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/shell.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/typescript.min.js"></script>
        
        <script>hljs.highlightAll();</script>
      </article>
      <nav>
        
        <a id="avatar-container" href="/">
          <img
            id="avatar"
            title="lingyin"
            src="https://avatars.githubusercontent.com/u/13548822"
          />
        </a>
        <p>岁月总是历久弥新，需要细细品尝。</p>
        <p>
          欢迎来到<a href="https://github.com/microtears"> lingyin </a>的开发者日志,
          这里是我的一些奇思妙想。
        </p>
        <p>
          它使用
          <a href="https://dart.dev/"> Dart </a>编写的一个专用于这个网站的静态网站生成器生成。
        </p>
        <div id="nav-break"></div>
        <p id="copyright">© 2019-2025 <a href="/">lingyin</a>.</p>
      </nav>
    </div>
    <footer>
      <p id="run-time"></span>
      <p id="build-time">Build time: 2025/10/10 10:4:35</span>
      <script>
        function updateTime() {
          const date1 = "2019/07/17 00:00:00";
          const date2 = new Date();
          const date3 = date2.getTime() - new Date(date1).getTime();
          const days = Math.floor(date3 / (24 * 3600 * 1000));
          const leave1 = date3 % (24 * 3600 * 1000);
          const hours = Math.floor(leave1 / (3600 * 1000));
          const leave2 = leave1 % (3600 * 1000);
          const minutes = Math.floor(leave2 / (60 * 1000));
          const leave3 = leave2 % (60 * 1000);
          const seconds = Math.round(leave3 / 1000);
          const element = document.getElementById("run-time");
          element.innerHTML =
            "Run   time: " + days + "d " + hours + "h " + minutes + "m " + seconds + "s";
        }

        setInterval(updateTime, 1000);
      </script>
    </footer>
  </main>
</body>
</html>